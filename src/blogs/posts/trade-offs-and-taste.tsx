import React from 'react';
import { IBlogPost } from '../all';
import { A, Heading2, P } from '../common';

export const SLUG = 'trade-offs-and-taste';
export const TITLE = 'Trade-offs and Taste';
export const DATE = '2024-09-27';
export const EXCERPT =
  'All meaningful code used to be written by humans, but not anymore. What does that mean for software engineers in a few years? Is it still worth learning how to code?';

const BlogPost: React.FC<any> = () => {
  return (
    <>
      <P>
        All meaningful code used to be written by humans, but not anymore.
        Today, 10-30% of code is generated by copilots working with a human
        programmer, and in just a few years virtually all new software will be
        created by autonomous agents directed by humans. What will happen to
        software engineers in a few years? Will we still need them? Is it still
        worth learning how to code?
      </P>
      <P>
        I think we’ll still have people who make software, but they’ll have a
        different skill set than the engineers around today. Their abilities
        will boil down to two necessary attributes: excellent trade off decision
        making and great taste.
      </P>
      <Heading2>Software Engineering Today</Heading2>
      <P>
        Software engineering today relies on engineers to hold a ton of
        information in their head and bring life to abstract ideas. They must be
        fluent in the syntax of relevant programming languages and have broad
        knowledge of available tools and frameworks. They need to understand
        their existing codebase and previous implementation choices. They need
        to be able to coordinate with product managers, designers, and other
        engineers to determine what to build. Then with all of this context,
        they must be able to fit structure around ambiguous features and
        physically type their mental mapping into a computer. Assuming they
        nailed this translation on the first go (it rarely works that way), they
        then test their work and iterate until the project is complete.
      </P>
      <P>
        This all encompassing software engineering role will seem archaic and
        amazing a decade from now, probably similar to how I view the legendary
        programmer Chris Sawyer that{' '}
        <A href="https://www.chrissawyergames.com/faq3.html">
          made RollerCoaster Tycoon in assembly language
        </A>{' '}
        (how the hell did he do that?!). The next generation of software makers
        won't believe the way we did things. They’ll orchestrate swarms of
        coding agents that take ideas, map them to an existing project, build
        it, test it, and iterate until the result is perfect. With directions
        from a human, “typing” and “thinking” speed will increase 1000x from
        today, allowing massive refactors, perfectly optimized changes, and
        debugging loops to happen and without human intervention.
      </P>
      <P>
        Most significantly, the time to make software will drop to essentially
        zero. If you can articulate your thoughts, agents will be ready to turn
        your intent into code. So, articulating your thoughts becomes the core
        challenge. Most of the key abilities and contextual understanding of a
        software engineer today will be handled by machines, except for the
        ability to make tradeoffs and have great taste. To build a great
        product, your job will be to build those skills and know how to
        communicate them accurately.
      </P>
      <Heading2>Trade Offs</Heading2>
      <P>
        As long as we live in a world constrained by physics, computer science,
        and capitalist markets, software engineering at a high level will be a
        game of trade offs. For every implementation decision, there’s a
        negative trade off to consider. An engineer must make decisions on
        platform dependence, system architecture, database design, and key
        algorithms all with trade offs around latency, accuracy, cost,
        reliability, and ethics. Great software engineers know how to evaluate
        decisions and make the best choice, and those choices will still be
        relevant when agents are generating our code.
      </P>
      <P>
        Building this muscle is fairly straightforward: work on more projects.
        Learning to code and building your own projects from scratch is a great
        way to do this, and one of the key reasons I think learning to code will
        be relevant in the future. Once you start thinking of your project as a
        series of logic gates and trade offs expressed through code, you’re
        thinking like an engineer.
      </P>
      <P>
        I think a software maker who understands the innards of a software
        system will be able to effectively communicate and make decisions with
        an AI agent counterpart far more effectively than someone who only knows
        what they want at a high level. Build your own systems today, learn how
        to weigh trade offs, and learn how to communicate them to be an
        effective agent orchestrator.
      </P>
      <Heading2>Taste</Heading2>
      <P>
        Having good taste is harder to nail down, but you know good taste when
        you see it. Good taste leads to good design in everything from the
        aesthetic of a product to its user experience. It’s more of an art than
        a science, and my views on what constitutes good taste are certainly
        influenced by{' '}
        <A href="https://www.paulgraham.com/taste.html">
          Paul Graham’s essays on the subject
        </A>
        .
      </P>
      <P>
        Especially in the near future, great taste will be extremely important
        while agent programming workflows get ironed out. Have you seen AI
        generated websites recently? They’re usually not great, in part because
        there isn’t a visual feedback loop and in part because they lack taste.
        I feel that in the same way that AI generated photos lack realism, AI
        generated software lacks design and visual taste.
      </P>
      <P>
        As a software maker with great taste, you need to deeply understand
        human-computer interaction and be opinionated in your unique approach to
        creating beautiful products. Developing taste takes practice that comes
        from using great products, launching great products, gathering user
        feedback, and reviewing user data. Some have a knack for it, and others
        will have to work at it. But good software taste can certainly be earned
        (ex. my earliest projects were garbage in every way, now they’re not too
        bad).
      </P>
      <P>
        As the agents get better and require less human intervention, a less
        experienced maker will be able to create fancier products. But these
        novice creators won’t stray far from the defaults inherent in AI models
        and end up building indistinguishable products (
        <A href="https://v0.dev/chat">see v0</A>). Breakout from the crowd and
        develop good taste.
      </P>
      <Heading2>How long do I have?</Heading2>
      <P>
        It’s hard to say how long tradeoffs and taste will be relevant as a
        skill set, but in my opinion they’ll certainly be the last things
        automated away. Writing code, fiddling with CSS, debugging, and
        searching stack overflow are almost certainly going to be things of the
        past. Makers in the next decade will be able to think bigger because the
        smaller stuff will be handled. You need to make sure you’re able to know
        what you want, be confident it will work, and express what you need.
      </P>
      <P>
        To get ahead, build something. Make a new project. Use new tools. Launch
        it to users and get offensive feedback from someone online. Develop a
        sense of what’s good software and learn how to make it run quickly,
        cheaply, and reliably.
      </P>
      <P>
        Soon we’ll put python and typescript to bed. Get ready for english as
        code.
      </P>
    </>
  );
};

export const TradeOffsAndTaste: IBlogPost = {
  slug: SLUG,
  title: TITLE,
  date: DATE,
  excerpt: EXCERPT,
  post: <BlogPost />,
};
