import React from 'react';
import { IBlogPost } from '../all';
import { A, Heading2, P } from '../common';

export const SLUG = 'tradeoffs-and-taste';
export const TITLE = 'Taste and Tradeoffs (DRAFT)';
export const DATE = '2024-10-09';
export const EXCERPT =
  'All meaningful code used to be written by humans, but not anymore. What does that mean for software engineers in a few years? Is it still worth learning how to code?';

const BlogPost: React.FC<any> = () => {
  return (
    <>
      <P>
        All meaningful code used to be written by humans, but it's not anymore.
        Today somewhere between 20-50% of code is generated by AI copilots, and
        in just a few years virtually all new software will be created by
        autonomous agents. So what will happen to software engineers? Is it
        still worth learning how to code?
      </P>
      <P>
        I've been writing code for a decade as a software engineer at Google and
        a startup CTO, and after years of using AI tools like Github Copilot and
        Cursor I think it's obvious that making software will never be the same.
        The process of creating a product or finishing a task is fundamentally
        different, and honestly it's much more enjoyable. A few years from now I
        think we’ll still need software engineers, but they’ll only need two key
        skills: the ability to decide system tradeoffs and a great sense of
        taste.
      </P>
      <Heading2>Software Engineering Today</Heading2>
      <P>
        Modern software engineering relies on engineers to hold a ton of
        information in their head and bring abstract ideas to life with code.
        They must be fluent in the syntax of relevant programming languages and
        have broad knowledge of available tools and frameworks. They must be
        aware of their their existing codebase and understand previous
        implementation choices. They need to be able to coordinate with product
        managers, designers, and other engineers to determine what to build.
        Then with all of this context, they must be able to fit structure around
        ambiguous features and physically type it all into a computer. Assuming
        they nailed this translation on the first go (it rarely works that way),
        they then test their work and iterate until the project is complete.
      </P>
      <P>
        This all encompassing software engineering role will seem archaic and
        amazing a decade from now, probably similar to how I view the legendary
        programmer Chris Sawyer that{' '}
        <A href="https://www.chrissawyergames.com/faq3.htm">
          made RollerCoaster Tycoon in assembly language
        </A>{' '}
        (so insane). Honestly, we have it pretty good today, but the next
        generation of software makers won't believe the way we did things.
      </P>

      <Heading2>Where We're Headed</Heading2>
      <P>
        Soon engineers will orchestrate swarms of coding agents that take ideas,
        map them onto a project, build it, test it, and iterate until the result
        works perfectly. With human directions and automated code generation,
        “typing” and "filling in the gaps" speed will increase 1000x allowing
        massive refactors, perfectly optimized changes, and debugging loops to
        happen and without human intervention.
      </P>
      <P>
        The time it takes to make software will drop to essentially zero. If you
        can articulate your thoughts, agents will be ready to turn your intent
        into code. So, articulating your thoughts and having the{' '}
        <span className="italic">right thoughts</span> becomes the core
        challenge. Some skills of today's software engineers will absolutely be
        handled by machines like understanding programming syntax, typing,
        testing, and debugging, but humans will still need to give direction on
        system tradeoffs and guide the agents to make a tasteful product. To
        build something great with software, your job will be to have these
        skills and communicate your intent clearly.
      </P>
      <P>Let's explore each skill and how to develop your abilities today.</P>
      <Heading2>Tradeoffs</Heading2>
      <P>
        As long as we live in a world constrained by physics, computer science,
        and capitalist markets, software engineering at a high level will be a
        game of tradeoffs. For every implementation decision, there’s a negative
        tradeoff to consider. An engineer must make decisions on platform
        dependence, system architecture, and key algorithms all with
        implications on latency, accuracy, cost, reliability, and ethics. Great
        software engineers will know which decisions they need to make, how to
        evaluate their decisions, and be able to make the right choice. Those
        choices will still be relevant when agents are generating our code.
      </P>
      <P>
        A great engineer will know all of the platforms and tools at their
        disposal and understand their pros and cons. They'll know when to
        specify implementation details and when to give the agents free reign.
        They'll know what questions to ask to give informed instructions and ask
        them often. They'll know how to effectively monitor the system and
        request refactors to ensure the system works as intended. They'll have
        total system awareness, but not deep system fluency (just like I can't
        read assembly today).
      </P>
      <P>
        It's worth noting that any tradeoffs related to developer productivity
        will no longer be relevant. Today all engineering teams grapple with
        difficult prioritization decisions: should we build feature A, build
        feature B, or fix tech debt C. Those decisions will be a thing of the
        past. What to prioritize will no longer be an issue, and you'll have
        free reign to build as fast as you can with unlimited engineering
        effort.
      </P>
      <P>
        Building your sense of tradeoff decision making today is fairly
        straightforward: work on more projects. Developing your own technical
        projects from scratch is a great way to do this, and one of the key
        reasons I think learning to code will be relevant in the future. Once
        you start thinking of your project as a series of tradeoffs expressed
        through code, you’re thinking like an engineer.
      </P>
      <P>
        I think a software engineer who understands the innards of their system
        will be able to effectively communicate and make decisions with an AI
        agent counterpart far more effectively than someone who only knows what
        they want at a high level. Build your own systems today, learn how to
        weigh tradeoffs, and learn how to communicate your choices.
      </P>
      <Heading2>Taste</Heading2>
      <P>
        Having good taste is harder to nail down, but you know good taste when
        you see it. Good taste leads to good design in everything from the
        aesthetic of a product to its user experience. It’s more of an art than
        a science, and my views on what constitutes good taste are certainly
        influenced by{' '}
        <A href="https://www.paulgraham.com/taste.html">
          Paul Graham’s essays on the subject
        </A>
        .
      </P>
      <P>
        Especially in the near future, great taste will be extremely important
        while agent programming workflows get ironed out. Have you seen AI
        generated websites recently? They’re usually not great, in part because
        there isn’t a visual feedback loop and in part because they lack taste.
        I feel that in the same way AI generated photos lack realism, AI
        generated software lacks design and visual taste.
      </P>
      <P>
        As a software maker with great taste, you need to deeply understand
        human-computer interaction and be opinionated in your unique approach to
        creating beautiful products. Developing taste takes practice that comes
        from using great products, launching great products, gathering user
        feedback, and reviewing user data. Some have a knack for it, and others
        will have to work at it. But good software taste can certainly be earned
        (ex. my earliest projects were garbage in every way, now they’re not too
        bad).
      </P>
      <P>
        As the agents get better and require less human intervention, a less
        experienced maker will be able to create fancier products. But these
        novice creators won’t stray far from the defaults inherent in AI models
        and end up building indistinguishable products (
        <A href="https://v0.dev/chat">see v0</A>). Breakout from the crowd and
        develop good taste.
      </P>
      <Heading2>How Long Do Those Matter?</Heading2>
      <P>
        It’s hard to say how long tradeoffs and taste will be relevant as a
        skill set, but in my opinion they’ll certainly be the last things
        automated away. Writing code, fiddling with CSS, debugging, and
        searching stack overflow are almost certainly going to be things of the
        past. Makers in the next decade will be able to think bigger because the
        smaller stuff will be handled. You need to make sure you’re able to know
        what you want, be confident it will work, and express what you need.
      </P>
      <P>
        To get ahead, build something. Make a new project. Use new tools. Launch
        it to users and get offensive feedback from someone online. Develop a
        sense of what’s good software and learn how to make it run quickly,
        cheaply, and reliably.
      </P>
      <P>
        Soon we’ll put python and typescript to bed. Get ready for english as
        code.
      </P>
    </>
  );
};

export const TradeoffsAndTaste: IBlogPost = {
  slug: SLUG,
  title: TITLE,
  date: DATE,
  excerpt: EXCERPT,
  post: <BlogPost />,
};
